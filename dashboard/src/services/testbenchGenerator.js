 Advanced Testbench Generator for FPGA Designs
class AdvancedTestbenchGenerator {
  constructor() {
    this.testStrategies = {
      'adder' {
        directed ['corner_cases', 'overflow_tests', 'carry_chain'],
        random ['constrained_random', 'weighted_distribution'],
        coverage ['functional', 'toggle', 'assertion']
      },
      'multiplier' {
        directed ['special_values', 'bit_patterns', 'signed_unsigned'],
        random ['uniform_distribution', 'corner_weighted'],
        coverage ['cross_coverage', 'range_coverage']
      },
      'memory' {
        directed ['address_walking', 'data_patterns', 'simultaneous_access'],
        random ['random_access', 'burst_patterns'],
        coverage ['address_coverage', 'data_coverage', 'protocol_coverage']
      }
    };
  }

  generateAdvancedTestbench(rtlModule, intent, options = {}) {
    const moduleName = rtlModule.match(modules+(w+))[1];
    const component = intent.component;
    const width = intent.parameters.width  8;
    
    const testbench = {
      header this.generateTestbenchHeader(moduleName),
      signals this.generateSignalDeclarations(rtlModule, intent),
      dut_instance this.generateDUTInstance(rtlModule),
      clock_reset this.generateClockAndReset(),
      directed_tests this.generateDirectedTests(component, width),
      random_tests this.generateRandomTests(component, width),
      coverage_groups this.generateCoverageGroups(component, width),
      assertions this.generateAssertions(component, width),
      main_test this.generateMainTestSequence(component),
      utilities this.generateUtilityTasks(component, width)
    };

    return this.assembleTestbench(testbench, moduleName);
  }

  generateTestbenchHeader(moduleName) {
    return `
`timescale 1ns1ps

 Advanced Testbench for ${moduleName}
 Generated by ChipChat FPGA Design Tool
 Includes Directed tests, Random tests, Functional Coverage, Assertions

module tb_${moduleName};

     Test control parameters
    parameter CLK_PERIOD = 10;   100MHz
    parameter TEST_TIMEOUT = 100000;
    parameter RANDOM_TEST_COUNT = 10000;
    parameter COVERAGE_GOAL = 95;
    
     Test statistics
    integer test_count = 0;
    integer pass_count = 0;
    integer fail_count = 0;
    integer coverage_bins_hit = 0;
    integer total_coverage_bins = 0;`;
  }

  generateSignalDeclarations(rtlModule, intent) {
    const width = intent.parameters.width  8;
    const component = intent.component;
    
    let signals = `
     Clock and Reset
    reg clk;
    reg rst_n;
    
     Test control signals
    reg test_enable;
    reg [310] test_vector_count;
    reg [70] current_test_id;`;

     Component-specific signals
    switch (component) {
      case 'adder'
        signals += `
     DUT signals
    reg [${width-1}0] a, b;
    reg cin;
    wire [${width-1}0] sum;
    wire cout;
    
     Expected results
    reg [${width}0] expected_result;
    wire [${width}0] actual_result = {cout, sum};`;
        break;
        
      case 'multiplier'
        signals += `
     DUT signals  
    reg [${width-1}0] a, b;
    wire [${2width-1}0] product;
    
     Expected results
    reg [${2width-1}0] expected_product;`;
        break;
        
      case 'memory'
        const addrWidth = Math.ceil(Math.log2(intent.parameters.depth  256));
        signals += `
     DUT signals
    reg we;
    reg [${addrWidth-1}0] addr;
    reg [${width-1}0] din;
    wire [${width-1}0] dout;
    
     Memory model for verification
    reg [${width-1}0] memory_model [0${(intent.parameters.depth  256)-1}];`;
        break;
    }

    return signals;
  }

  generateDUTInstance(rtlModule) {
    const moduleName = rtlModule.match(modules+(w+))[1];
    const portMatches = rtlModule.match(modules+w+s(([sS])););
    
    if (!portMatches) return ` Error Could not parse module ports`;
    
    const ports = portMatches[1].split(',').map(port = {
      const portName = port.trim().split(s+).pop();
      return `        .${portName}(${portName})`;
    }).join(',n');

    return `
     Device Under Test instantiation
    ${moduleName} dut (
${ports}
    );`;
  }

  generateClockAndReset() {
    return `
     Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD2) clk = ~clk;
    end
    
     Reset generation
    initial begin
        rst_n = 0;
        test_enable = 0;
        #(CLK_PERIOD5) rst_n = 1;
        #(CLK_PERIOD2) test_enable = 1;
    end`;
  }

  generateDirectedTests(component, width) {
    switch (component) {
      case 'adder'
        return `
     Directed test cases for adder
    task run_directed_tests;
        begin
            $display(n=== Running Directed Tests ===);
            current_test_id = 1;
            
             Test 1 Zero + Zero
            test_adder(0, 0, 0, Zero addition);
            
             Test 2 Maximum values
            test_adder(${2width-1}, ${2width-1}, 1, Maximum overflow);
            
             Test 3 Carry propagation
            test_adder(${2width-1}, 1, 0, Carry propagation);
            
             Test 4 Alternating patterns
            test_adder(${parseInt('10101010'.slice(0,width), 2)  0xAA}, ${parseInt('01010101'.slice(0,width), 2)  0x55}, 0, Alternating patterns);
            
             Test 5 Walking ones
            for (int i = 0; i  ${width}; i++) begin
                test_adder(1  i, 0, 0, $sformatf(Walking ones bit %0d, i));
            end
            
             Test 6 Walking zeros  
            for (int i = 0; i  ${width}; i++) begin
                test_adder(~(1  i), 0, 0, $sformatf(Walking zeros bit %0d, i));
            end
            
            $display(Directed tests completed %0d passed, %0d failed, pass_count, fail_count);
        end
    endtask`;

      case 'multiplier'
        return `
     Directed test cases for multiplier
    task run_directed_tests;
        begin
            $display(n=== Running Directed Tests ===);
            current_test_id = 1;
            
             Test 1 Multiply by zero
            test_multiplier(0, $random, Multiply by zero);
            test_multiplier($random, 0, Multiply by zero (swapped));
            
             Test 2 Multiply by one
            test_multiplier(1, ${2width-1}, Multiply by one);
            test_multiplier(${2width-1}, 1, Multiply by one (swapped));
            
             Test 3 Power of 2 multiplication
            for (int i = 0; i  ${width-1}; i++) begin
                test_multiplier(1  i, ${2width-1}, $sformatf(Power of 2 2^%0d, i));
            end
            
             Test 4 Maximum values
            test_multiplier(${2width-1}, ${2width-1}, Maximum values);
            
             Test 5 Bit patterns
            test_multiplier(${parseInt('10101010'.slice(0,width), 2)  0xAA}, ${parseInt('01010101'.slice(0,width), 2)  0x55}, Alternating patterns);
            
            $display(Directed tests completed %0d passed, %0d failed, pass_count, fail_count);
        end
    endtask`;

      case 'memory'
        const depth = 256;  Default depth
        return `
     Directed test cases for memory
    task run_directed_tests;
        begin
            $display(n=== Running Directed Tests ===);
            current_test_id = 1;
            
             Test 1 WriteRead all locations
            for (int i = 0; i  ${depth}; i++) begin
                test_memory_write(i, i[${width-1}0], $sformatf(Write addr %0d, i));
                test_memory_read(i, i[${width-1}0], $sformatf(Read addr %0d, i));
            end
            
             Test 2 Address walking
            for (int i = 0; i  $clog2(${depth}); i++) begin
                test_memory_write(1  i, 8'hAA, $sformatf(Walking address bit %0d, i));
                test_memory_read(1  i, 8'hAA, $sformatf(Walking address read %0d, i));
            end
            
             Test 3 Data patterns
            test_memory_write(0, 8'h00, All zeros data);
            test_memory_write(1, 8'hFF, All ones data);
            test_memory_write(2, 8'hAA, Alternating data);
            test_memory_write(3, 8'h55, Inverse alternating);
            
            test_memory_read(0, 8'h00, Read all zeros);
            test_memory_read(1, 8'hFF, Read all ones);
            test_memory_read(2, 8'hAA, Read alternating);
            test_memory_read(3, 8'h55, Read inverse alternating);
            
            $display(Directed tests completed %0d passed, %0d failed, pass_count, fail_count);
        end
    endtask`;

      default
        return `
     Generic directed tests
    task run_directed_tests;
        begin
            $display(n=== Running Directed Tests ===);
             Add component-specific directed tests here
        end
    endtask`;
    }
  }

  generateRandomTests(component, width) {
    return `
     Constrained random testing
    task run_random_tests;
        begin
            $display(n=== Running Random Tests ===);
            current_test_id = 100;
            
            for (int i = 0; i  RANDOM_TEST_COUNT; i++) begin
                 Generate constrained random stimulus
                case (component)
                    adder begin
                        automatic logic [${width-1}0] rand_a = $random;
                        automatic logic [${width-1}0] rand_b = $random;
                        automatic logic rand_cin = $random & 1;
                        test_adder(rand_a, rand_b, rand_cin, $sformatf(Random test %0d, i));
                    end
                    
                    multiplier begin
                        automatic logic [${width-1}0] rand_a = $random;
                        automatic logic [${width-1}0] rand_b = $random;
                        test_multiplier(rand_a, rand_b, $sformatf(Random test %0d, i));
                    end
                    
                    memory begin
                        automatic logic [${Math.ceil(Math.log2(256))-1}0] rand_addr = $random;
                        automatic logic [${width-1}0] rand_data = $random;
                        automatic logic rand_we = $random & 1;
                        
                        if (rand_we) begin
                            test_memory_write(rand_addr, rand_data, $sformatf(Random write %0d, i));
                        end else begin
                            test_memory_read(rand_addr, memory_model[rand_addr], $sformatf(Random read %0d, i));
                        end
                    end
                endcase
                
                 Periodic coverage reporting
                if (i % 1000 == 0) begin
                    $display(Random test progress %0d%0d completed, i, RANDOM_TEST_COUNT);
                end
            end
            
            $display(Random tests completed %0d total tests, RANDOM_TEST_COUNT);
        end
    endtask`;
  }

  generateCoverageGroups(component, width) {
    switch (component) {
      case 'adder'
        return `
     Functional coverage for adder
    covergroup adder_cg @(posedge clk);
        option.per_instance = 1;
        option.name = adder_coverage;
        
         Input value coverage
        cp_a coverpoint a {
            bins zero = {0};
            bins low = {[1${Math.floor((2width-1)4)}]};
            bins mid = {[${Math.floor((2width-1)4)+1}${Math.floor(3(2width-1)4)}]};
            bins high = {[${Math.floor(3(2width-1)4)+1}${2width-2}]};
            bins max = {${2width-1}};
        }
        
        cp_b coverpoint b {
            bins zero = {0};
            bins low = {[1${Math.floor((2width-1)4)}]};
            bins mid = {[${Math.floor((2width-1)4)+1}${Math.floor(3(2width-1)4)}]};
            bins high = {[${Math.floor(3(2width-1)4)+1}${2width-2}]};
            bins max = {${2width-1}};
        }
        
        cp_cin coverpoint cin {
            bins carry_0 = {0};
            bins carry_1 = {1};
        }
        
         Output coverage
        cp_cout coverpoint cout {
            bins no_overflow = {0};
            bins overflow = {1};
        }
        
         Cross coverage
        cross_inputs cross cp_a, cp_b, cp_cin;
        cross_overflow cross cp_a, cp_b, cp_cout;
    endgroup
    
    adder_cg adder_coverage_inst = new();`;

      case 'multiplier'
        return `
     Functional coverage for multiplier  
    covergroup multiplier_cg @(posedge clk);
        option.per_instance = 1;
        option.name = multiplier_coverage;
        
        cp_a coverpoint a {
            bins zero = {0};
            bins one = {1};
            bins small = {[215]};
            bins medium = {[16${2(width-2)-1}]};
            bins large = {[${2(width-2)}${2width-2}]};
            bins max = {${2width-1}};
        }
        
        cp_b coverpoint b {
            bins zero = {0};
            bins one = {1};
            bins small = {[215]};
            bins medium = {[16${2(width-2)-1}]};
            bins large = {[${2(width-2)}${2width-2}]};
            bins max = {${2width-1}};
        }
        
        cp_product_range coverpoint product {
            bins zero = {0};
            bins small = {[1255]};
            bins medium = {[256${2(2width-2)-1}]};
            bins large = {[${2(2width-2)}${2(2width)-2}]};
            bins max = {${2(2width)-1}};
        }
        
        cross_special cross cp_a, cp_b {
            bins zero_mult = binsof(cp_a.zero)  binsof(cp_b.zero);
            bins one_mult = binsof(cp_a.one)  binsof(cp_b.one);
            bins max_mult = binsof(cp_a.max) && binsof(cp_b.max);
        }
    endgroup
    
    multiplier_cg multiplier_coverage_inst = new();`;

      default
        return `
     Generic functional coverage
    covergroup generic_cg @(posedge clk);
        option.per_instance = 1;
         Add component-specific coverage points
    endgroup
    
    generic_cg coverage_inst = new();`;
    }
  }

  generateAssertions(component, width) {
    switch (component) {
      case 'adder'
        return `
     Assertions for adder verification
    
     Basic functionality assertion
    property adder_correctness;
        @(posedge clk) disable iff (!rst_n)
        (a + b + cin) == {cout, sum};
    endproperty
    assert_adder_correctness assert property (adder_correctness)
    else $error(Adder result incorrect a=%h, b=%h, cin=%b, expected=%h, got=%h, 
                a, b, cin, a + b + cin, {cout, sum});
    
     Overflow detection
    property overflow_detection;
        @(posedge clk) disable iff (!rst_n)
        (a[${width-1}] == b[${width-1}] && sum[${width-1}] != a[${width-1}]) - cout;
    endproperty
    assert_overflow assert property (overflow_detection)
    else $error(Overflow not detected correctly);
    
     Carry propagation timing
    property carry_stable;
        @(posedge clk) disable iff (!rst_n)
        $stable(a) && $stable(b) && $stable(cin) - ##1 $stable({cout, sum});
    endproperty
    assert_carry_stable assert property (carry_stable)
    else $warning(Carry propagation timing issue);`;

      case 'multiplier'
        return `
     Assertions for multiplier verification
    
     Basic functionality
    property multiplier_correctness;
        @(posedge clk) disable iff (!rst_n)
        (a  b) == product;
    endproperty
    assert_multiplier_correctness assert property (multiplier_correctness)
    else $error(Multiplier result incorrect a=%h, b=%h, expected=%h, got=%h, 
                a, b, a  b, product);
    
     Zero multiplication
    property zero_mult;
        @(posedge clk) disable iff (!rst_n)
        (a == 0  b == 0) - product == 0;
    endproperty
    assert_zero_mult assert property (zero_mult)
    else $error(Zero multiplication failed);
    
     Identity multiplication  
    property identity_mult;
        @(posedge clk) disable iff (!rst_n)
        (a == 1) - product == b;
    endproperty
    assert_identity_mult assert property (identity_mult)
    else $error(Identity multiplication failed);`;

      default
        return `
     Generic assertions
     Add component-specific assertions here`;
    }
  }

  generateUtilityTasks(component, width) {
    switch (component) {
      case 'adder'
        return `
     Utility tasks for adder testing
    task test_adder(input [${width-1}0] test_a, test_b, input test_cin, input string test_name);
        begin
            a = test_a;
            b = test_b; 
            cin = test_cin;
            expected_result = test_a + test_b + test_cin;
            
            @(posedge clk);
            #1;  Small delay for signal propagation
            
            test_count++;
            pass_count++;
            $display(PASS %s - addr=%h, data=%h written, test_name, test_addr, test_data);
        end
    endtask
    
    task test_memory_read(input [${Math.ceil(Math.log2(256))-1}0] test_addr, input [${width-1}0] expected_data, input string test_name);
        begin
            addr = test_addr;
            we = 0;
            
            @(posedge clk);
            #1;
            
            test_count++;
            if (dout === expected_data) begin
                pass_count++;
                $display(PASS %s - addr=%h, data=%h, test_name, test_addr, dout);
            end else begin
                fail_count++;
                $error(FAIL %s - addr=%h, expected=%h, got=%h, 
                       test_name, test_addr, expected_data, dout);
            end
        end
    endtask`;

      default
        return `
     Generic utility tasks
    task check_result(input string test_name);
        begin
            test_count++;
             Add component-specific checking logic
        end
    endtask`;
    }
  }

  generateMainTestSequence(component) {
    return `
     Main test sequence
    initial begin
         Test environment setup
        $dumpfile(tb_${component}.vcd);
        $dumpvars(0, tb_${component});
        $timeformat(-9, 2,  ns, 10);
        
         Initialize signals
        initialize_signals();
        
         Wait for reset deassertion
        wait(rst_n && test_enable);
        repeat(5) @(posedge clk);
        
        $display(n + =60);
        $display(Starting ${component.toUpperCase()} Testbench);
        $display(=60);
        $display(Target Coverage Goal %0d%%, COVERAGE_GOAL);
        $display(Random Test Count %0d, RANDOM_TEST_COUNT);
        
         Run test phases
        fork
             Test execution thread
            begin
                run_directed_tests();
                run_random_tests();
                run_corner_case_tests();
                run_stress_tests();
            end
            
             Timeout watchdog
            begin
                #TEST_TIMEOUT;
                $error(Test timeout reached!);
                $finish;
            end
            
             Coverage monitoring thread
            begin
                monitor_coverage();
            end
        join_any
        
         Final reporting
        generate_final_report();
        
         End simulation
        repeat(10) @(posedge clk);
        $display(nSimulation completed successfully!);
        $finish;
    end
    
     Initialize all signals to known values
    task initialize_signals;
        begin
            current_test_id = 0;
            test_vector_count = 0;
            
             Component-specific initialization
            case(${component})
                adder begin
                    a = 0; b = 0; cin = 0;
                end
                multiplier begin
                    a = 0; b = 0;
                end
                memory begin
                    addr = 0; din = 0; we = 0;
                     Initialize memory model
                    for (int i = 0; i  256; i++) begin
                        memory_model[i] = 0;
                    end
                end
            endcase
        end
    endtask
    
     Corner case testing
    task run_corner_case_tests;
        begin
            $display(n=== Running Corner Case Tests ===);
            current_test_id = 200;
            
            case(${component})
                adder begin
                     Boundary conditions
                    test_adder(${2width-1}, 0, 1, Max + 0 + carry);
                    test_adder(0, ${2width-1}, 1, 0 + Max + carry);
                    
                     Bit transitions
                    for (int i = 0; i  ${width-1}; i++) begin
                        test_adder((1  (i+1)) - 1, 1, 0, $sformatf(Bit transition %0d-%0d, i, i+1));
                    end
                end
                
                multiplier begin
                     Powers of 2
                    for (int i = 0; i  ${width}; i++) begin
                        test_multiplier(1  i, ${2width-1}, $sformatf(Power of 2 2^%0d  max, i));
                    end
                    
                     Near maximum values
                    test_multiplier(${2width-1}, ${2width-1}, Max  Max);
                    test_multiplier(${2width-2}, ${2width-1}, Near-max combinations);
                end
                
                memory begin
                     Address boundary tests
                    test_memory_write(0, 8'hAA, First address);
                    test_memory_write(255, 8'h55, Last address);
                    
                     Data pattern tests
                    for (int i = 0; i  ${width}; i++) begin
                        test_memory_write(i, 1  i, $sformatf(Walking 1s data bit %0d, i));
                        test_memory_read(i, 1  i, $sformatf(Read walking 1s bit %0d, i));
                    end
                end
            endcase
            
            $display(Corner case tests completed);
        end
    endtask
    
     Stress testing with rapid stimulus changes
    task run_stress_tests;
        begin
            $display(n=== Running Stress Tests ===);
            current_test_id = 300;
            
             High-frequency stimulus changes
            for (int i = 0; i  1000; i++) begin
                case(${component})
                    adder begin
                        a = $random; b = $random; cin = $random;
                        @(posedge clk);
                    end
                    multiplier begin
                        a = $random; b = $random;
                        @(posedge clk);
                    end
                    memory begin
                        addr = $random; din = $random; we = $random;
                        @(posedge clk);
                    end
                endcase
            end
            
            $display(Stress tests completed);
        end
    endtask
    
     Coverage monitoring task
    task monitor_coverage;
        real current_coverage;
        begin
            forever begin
                #(CLK_PERIOD  1000);  Check every 1000 cycles
                
                 Get coverage percentage (implementation depends on tool)
                current_coverage = $get_coverage();
                
                if (current_coverage = COVERAGE_GOAL) begin
                    $display(nCoverage goal reached %.2f%%, current_coverage);
                    break;
                end
                
                if (test_count % 5000 == 0) begin
                    $display(Coverage update %.2f%% (Goal %0d%%), current_coverage, COVERAGE_GOAL);
                end
            end
        end
    endtask
    
     Final test report generation
    task generate_final_report;
        real pass_rate;
        real coverage_achieved;
        begin
            pass_rate = (pass_count  100.0)  test_count;
            coverage_achieved = $get_coverage();
            
            $display(n + =60);
            $display(FINAL TEST REPORT);
            $display(=60);
            $display(Component %s, ${component}.toupper());
            $display(Total Tests %0d, test_count);
            $display(Passed %0d, pass_count);
            $display(Failed %0d, fail_count);
            $display(Pass Rate %.2f%%, pass_rate);
            $display(Coverage Achieved %.2f%%, coverage_achieved);
            $display(Coverage Goal %0d%%, COVERAGE_GOAL);
            
            if (fail_count == 0) begin
                $display(n✓ ALL TESTS PASSED!);
            end else begin
                $display(n✗ %0d TESTS FAILED!, fail_count);
            end
            
            if (coverage_achieved = COVERAGE_GOAL) begin
                $display(✓ Coverage goal achieved!);
            end else begin
                $display(✗ Coverage goal not met (%.2f%%  %0d%%), coverage_achieved, COVERAGE_GOAL);
            end
            
             Detailed coverage breakdown
            $display(nCoverage Breakdown);
            $display(- Functional Coverage %.2f%%, coverage_achieved);
            $display(- Code Coverage %.2f%%, $get_coverage(CODE));
            $display(- Assertion Coverage %.2f%%, $get_coverage(ASSERT));
            
            $display(=60);
        end
    endtask`;
  }

  assembleTestbench(components, moduleName) {
    return `${components.header}
${components.signals}
${components.dut_instance}
${components.clock_reset}
${components.coverage_groups}
${components.assertions}
${components.directed_tests}
${components.random_tests}
${components.utilities}
${components.main_test}

endmodule

 Additional verification components

 Custom assertion library
`include custom_assertions.sv

 Coverage analysis utilities
class CoverageAnalyzer;
    real functional_coverage;
    real code_coverage;
    real assertion_coverage;
    
    function new();
        functional_coverage = 0.0;
        code_coverage = 0.0;
        assertion_coverage = 0.0;
    endfunction
    
    function real get_total_coverage();
        return (functional_coverage + code_coverage + assertion_coverage)  3.0;
    endfunction
    
    function void report_coverage();
        $display(Coverage Analysis);
        $display(  Functional %.2f%%, functional_coverage);
        $display(  Code %.2f%%, code_coverage);
        $display(  Assertion %.2f%%, assertion_coverage);
        $display(  Total %.2f%%, get_total_coverage());
    endfunction
endclass

 Performance monitor
class PerformanceMonitor;
    time start_time;
    time end_time;
    integer cycle_count;
    
    function new();
        start_time = 0;
        end_time = 0;
        cycle_count = 0;
    endfunction
    
    function void start_monitoring();
        start_time = $time;
        cycle_count = 0;
    endfunction
    
    function void stop_monitoring();
        end_time = $time;
    endfunction
    
    function void report_performance();
        real simulation_time_ns;
        real frequency_mhz;
        
        simulation_time_ns = (end_time - start_time);
        frequency_mhz = (cycle_count  1000.0)  simulation_time_ns;
        
        $display(Performance Analysis);
        $display(  Simulation time %.2f ns, simulation_time_ns);
        $display(  Clock cycles %0d, cycle_count);
        $display(  Effective frequency %.2f MHz, frequency_mhz);
    endfunction
endclass`;
  }

   Generate makefile for simulation
  generateMakefile(moduleName, toolchain = 'questa') {
    return `# Makefile for ${moduleName} simulation
# Generated by ChipChat FPGA Design Tool

# Tool configuration
SIMULATOR = ${toolchain}
TOP_MODULE = tb_${moduleName}
SRC_FILES = ${moduleName}.sv tb_${moduleName}.sv
VCD_FILE = ${moduleName}.vcd

# Simulation flags
VLOG_FLAGS = +incdir+. -sv -work work
VSIM_FLAGS = -voptargs=+acc -t ps -lib work

# Default target
all compile simulate

# Compile source files
compile
t${toolchain === 'questa'  'vlog'  'xvlog'} $(VLOG_FLAGS) $(SRC_FILES)

# Run simulation
simulate
t${toolchain === 'questa'  'vsim'  'xsim'} $(VSIM_FLAGS) $(TOP_MODULE) -do run -all; quit

# Generate coverage report
coverage
t${toolchain === 'questa'  'vcover report'  'xcrg'} -html coverage.ucdb

# Clean build artifacts
clean
trm -rf work .wlf .vcd .log transcript .ucdb coverage_html

# View waveforms
view
t${toolchain === 'questa'  'vsim'  'gtkwave'} -view $(VCD_FILE)

.PHONY all compile simulate coverage clean view`;
  }

   Generate complete verification environment
  generateVerificationEnvironment(rtlModule, intent, options = {}) {
    const testbench = this.generateAdvancedTestbench(rtlModule, intent, options);
    const makefile = this.generateMakefile(intent.component);
    
    return {
      testbench testbench,
      makefile makefile,
      verification_plan this.generateVerificationPlan(intent),
      coverage_plan this.generateCoveragePlan(intent),
      assertion_plan this.generateAssertionPlan(intent)
    };
  }

  generateVerificationPlan(intent) {
    return `
# Verification Plan for ${intent.component.toUpperCase()}

## Objectives
- Verify functional correctness under all input conditions
- Achieve ${intent.component === 'memory'  '98'  '95'}% functional coverage
- Validate timing requirements
- Ensure synthesis compatibility

## Test Strategy
1. Directed Tests Corner cases and known scenarios
2. Random Tests Constrained random stimulus
3. Stress Tests High-frequency operation
4. Regression Tests Automated nightly runs

## Coverage Goals
- Functional Coverage 95%
- Code Coverage 100%
- Assertion Coverage 90%

## Success Criteria
- Zero functional failures
- All assertions pass
- Coverage goals met
- Synthesis clean (no warnings)
`;
  }

  generateCoveragePlan(intent) {
    return `
# Coverage Plan for ${intent.component.toUpperCase()}

## Functional Coverage Points
${intent.component === 'adder'  
`- Input value ranges (zero, low, medium, high, max)
- Carry input and output states
- Overflow conditions
- Cross coverage of inputs and outputs` 
intent.component === 'multiplier' 
`- Input value ranges and special values (0, 1, max)
- Product result ranges
- Partial product patterns
- Resource utilization scenarios` 
`- Address space coverage
- Data pattern coverage
- Readwrite operation coverage
- Simultaneous access patterns`}

## Code Coverage Requirements
- Statement Coverage 100%
- Branch Coverage 100%
- Expression Coverage 95%
- FSM Coverage 100% (if applicable)

## Assertion Coverage
- All properties must be exercised
- Both pass and fail scenarios (where safe)
- Temporal assertions fully covered
`;
  }

  generateAssertionPlan(intent) {
    return `
# Assertion Plan for ${intent.component.toUpperCase()}

## Functional Assertions
${intent.component === 'adder' 
`- Arithmetic correctness (a + b + cin) == {cout, sum}
- Overflow detection accuracy
- Carry propagation timing
- Input stability requirements` 
intent.component === 'multiplier' 
`- Multiplication correctness (a  b) == product
- Zero multiplication property
- Identity multiplication property
- Commutative property verification` 
`- Writeread data integrity
- Address decode correctness
- Memory access protocol compliance
- Data retention verification`}

## Temporal Assertions
- Setup and hold time requirements
- Clock domain crossing safety
- Reset behavior verification
- Pipeline stage progression (if applicable)

## Safety Assertions
- No X propagation in outputs
- No metastability detection
- Resource constraint compliance
`;
  }
}

 Export for use in ChipChat application
export default AdvancedTestbenchGenerator;
            if (actual_result === expected_result) begin
                pass_count++;
                $display(PASS %s - a=%h, b=%h, cin=%b, result=%h, 
                        test_name, test_a, test_b, test_cin, actual_result);
            end else begin
                fail_count++;
                $error(FAIL %s - a=%h, b=%h, cin=%b, expected=%h, got=%h, 
                       test_name, test_a, test_b, test_cin, expected_result, actual_result);
            end
        end
    endtask`;

      case 'multiplier'
        return `
     Utility tasks for multiplier testing
    task test_multiplier(input [${width-1}0] test_a, test_b, input string test_name);
        begin
            a = test_a;
            b = test_b;
            expected_product = test_a  test_b;
            
            @(posedge clk);
            #1;
            
            test_count++;
            if (product === expected_product) begin
                pass_count++;
                $display(PASS %s - a=%h, b=%h, product=%h, 
                        test_name, test_a, test_b, product);
            end else begin
                fail_count++;
                $error(FAIL %s - a=%h, b=%h, expected=%h, got=%h, 
                       test_name, test_a, test_b, expected_product, product);
            end
        end
    endtask`;

      case 'memory'
        return `
     Utility tasks for memory testing
    task test_memory_write(input [${Math.ceil(Math.log2(256))-1}0] test_addr, input [${width-1}0] test_data, input string test_name);
        begin
            addr = test_addr;
            din = test_data;
            we = 1;
            
            @(posedge clk);
            we = 0;
            
             Update memory model
            memory_model[test_addr] = test_data;
            
            test_count++;